<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Beam DSLs: SQL</title>
  <meta name="description" content="Apache Beam is an open source, unified model and set of language-specific SDKs for defining and executing data processing workflows, and also data ingestion and integration flows, supporting Enterprise Integration Patterns (EIPs) and Domain Specific Languages (DSLs). Dataflow pipelines simplify the mechanics of large-scale batch and streaming data processing and can run on a number of runtimes like Apache Flink, Apache Spark, and Google Cloud Dataflow (a cloud service). Beam also brings DSL in different languages, allowing users to easily implement their data integration processes.
">
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400" rel="stylesheet">
  <link rel="stylesheet" href="/css/site.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js"></script>
  <script src="/js/bootstrap.min.js"></script>
  <script src="/js/language-switch.js"></script>
  <script src="/js/fix-menu.js"></script>
  <script src="/js/section-nav.js"></script>
  <script src="/js/page-nav.js"></script>
  <link rel="canonical" href="https://beam.apache.org/documentation/dsls/sql/" data-proofer-ignore>
  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico">
  <link rel="alternate" type="application/rss+xml" title="Apache Beam" href="https://beam.apache.org/feed.xml">
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-73650088-1', 'auto');
    ga('send', 'pageview');
  </script>
</head>

  <body class="body" data-spy="scroll" data-target=".page-nav" data-offset="0">
    <nav class="header navbar navbar-fixed-top">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <a href="/" class="navbar-brand" >
        <img alt="Brand" style="height: 25px" src="/images/beam_logo_navbar.png">
      </a>
    </div>

    <div class="navbar-mask closed"></div>

    <div id="navbar" class="navbar-container closed">
      <ul class="nav navbar-nav">
        <li>
          <a href="/get-started/beam-overview/">Get Started</a>
        </li>
        <li>
          <a href="/documentation/">Documentation</a>
        </li>
        <li>
          <a href="/documentation/sdks/java/">SDKS</a>
        </li>
        <li>
          <a href="/documentation/runners/capability-matrix/">RUNNERS</a>
        </li>
        <li>
          <a href="/contribute/">Contribute</a>
        </li>
        <li><a href="/blog">Blog</a></li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"><img src="https://www.apache.org/foundation/press/kit/feather_small.png" alt="Apache Logo" style="height:20px;"><span class="caret"></span></a>
          <ul class="dropdown-menu dropdown-menu-right">
            <li><a href="http://www.apache.org/">ASF Homepage</a></li>
            <li><a href="http://www.apache.org/licenses/">License</a></li>
            <li><a href="http://www.apache.org/security/">Security</a></li>
            <li><a href="http://www.apache.org/foundation/thanks.html">Thanks</a></li>
            <li><a href="http://www.apache.org/foundation/sponsorship.html">Sponsorship</a></li>
            <li><a href="https://www.apache.org/foundation/policies/conduct">Code of Conduct</a></li>
          </ul>
        </li>
      </ul>
    </div>
</nav>

    <div class="clearfix container-main-content">
      <div class="section-nav closed" data-offset-top="90" data-offset-bottom="500">
        <span class="section-nav-back glyphicon glyphicon-menu-left"></span>
        <nav>
          <ul class="section-nav-list" data-section-nav>
            <li><span class="section-nav-list-main-title">SDKS</span></li>

<li>
  <span class="section-nav-list-title">Java SDK</span>
  <ul class="section-nav-list">
    <li><a href="/documentation/sdks/java/">Java SDK overview</a></li>
    <li><a href="/documentation/sdks/javadoc/2.4.0/" target="_blank">Java SDK API reference <img src="/images/external-link-icon.png"
                                                                                                                                   width="14" height="14"
                                                                                                                                   alt="External link."></a>
    </li>
    <li><a href="/documentation/sdks/java-extensions/">Java SDK extensions</a></li>
    <li><a href="/documentation/sdks/java/nexmark/">Nexmark benchmark suite</a></li>
  </ul>
</li>

<li>
  <span class="section-nav-list-title">Python SDK</span>
  <ul class="section-nav-list">
    <li><a href="/documentation/sdks/python/">Python SDK overview</a></li>
    <li><a href="/documentation/sdks/pydoc/2.4.0/" target="_blank">Python SDK API reference <img src="/images/external-link-icon.png"
                                                                                                                                   width="14" height="14"
                                                                                                                                   alt="External link."></a>
    </li>
    <li><a href="/documentation/sdks/python-type-safety/">Ensuring Python type safety</a></li>
    <li><a href="/documentation/sdks/python-pipeline-dependencies/">Managing pipeline dependencies</a></li>
    <li><a href="/documentation/sdks/python-custom-io/">Creating new sources and sinks</a></li>
  </ul>
</li>

<li>
  <span class="section-nav-list-title">DSLs</span>
  <ul class="section-nav-list">
    <li><a href="/documentation/dsls/sql/">SQL</a></li>
  </ul>
</li>

          </ul>
        </nav>
      </div>

      <nav class="page-nav clearfix" data-offset-top="90" data-offset-bottom="500">
        

<ul class="nav">
  <li><a href="#overview">1. Overview</a></li>
  <li><a href="#usage">2. Usage of DSL APIs</a>
    <ul>
      <li><a href="#row">Row</a></li>
      <li><a href="#beamsql">BeamSql</a></li>
    </ul>
  </li>
  <li><a href="#functionality">3. Functionality in Beam SQL</a>
    <ul>
      <li><a href="#features">3.1. Supported Features</a></li>
      <li><a href="#data-types">3.2. Data Types</a></li>
      <li><a href="#built-in-functions">3.3. Built-in SQL functions</a></li>
    </ul>
  </li>
  <li><a href="#internals-of-sql">4. Internals of Beam SQL</a></li>
</ul>


      </nav>

      <div class="body__contained body__section-nav">
        <h1 id="beam-sql">Beam SQL</h1>

<p>This page describes the implementation of Beam SQL, and how to simplify a Beam pipeline with DSL APIs.</p>

<h2 id="overview">1. Overview</h2>

<p>SQL is a well-adopted standard to process data with concise syntax. With DSL APIs (currently available only in Java), now <code class="highlighter-rouge">PCollections</code> can be queried with standard SQL statements, like a regular table. The DSL APIs leverage <a href="http://calcite.apache.org/">Apache Calcite</a> to parse and optimize SQL queries, then translate into a composite Beam <code class="highlighter-rouge">PTransform</code>. In this way, both SQL and normal Beam <code class="highlighter-rouge">PTransforms</code> can be mixed in the same pipeline.</p>

<p>There are two main pieces to the SQL DSL API:</p>

<ul>
  <li><a href="/documentation/sdks/javadoc/2.4.0/index.html?org/apache/beam/sdk/extensions/sql/BeamSql.html">BeamSql</a>: the interface for creating <code class="highlighter-rouge">PTransforms</code> from SQL queries;</li>
  <li><a href="/documentation/sdks/javadoc/2.4.0/index.html?org/apache/beam/sdk/values/Row.html">Row</a> contains named columns with corresponding data types. Beam SQL queries can be made only against collections of type <code class="highlighter-rouge">PCollection&lt;Row&gt;</code>;</li>
</ul>

<p>We’ll look at each of these below.</p>

<h2 id="usage">2. Usage of DSL APIs</h2>

<h3 id="row">Row</h3>

<p>Before applying a SQL query to a <code class="highlighter-rouge">PCollection</code>, the data in the collection must be in <code class="highlighter-rouge">Row</code> format. A <code class="highlighter-rouge">Row</code> represents a single, immutable record in a Beam SQL <code class="highlighter-rouge">PCollection</code>. The names and types of the fields/columns in the row are defined by its associated <a href="/documentation/sdks/javadoc/2.4.0/index.html?org/apache/beam/sdk/values/RowType.html">RowType</a>.
For SQL queries, you should use the <a href="/documentation/sdks/javadoc/2.4.0/index.html?org/apache/beam/sdk/extensions/sql/RowSqlType.html">RowSqlType.builder()</a> to create <code class="highlighter-rouge">RowTypes</code>, it allows creating schemas with all supported SQL types (see <a href="#data-types">Data Types</a> for more details on supported primitive data types).</p>

<p>A <code class="highlighter-rouge">PCollection&lt;Row&gt;</code> can be obtained multiple ways, for example:</p>

<ul>
  <li>
    <p><strong>From in-memory data</strong> (typically for unit testing).</p>

    <p><strong>Note:</strong> you have to explicitly specify the <code class="highlighter-rouge">Row</code> coder. In this example we’re doing it by calling <code class="highlighter-rouge">Create.of(..).withCoder()</code>:</p>

    <div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="c1">// Define the record type (i.e., schema).</span>
<span class="n">RowType</span> <span class="n">appType</span> <span class="o">=</span> 
    <span class="n">RowSqlType</span>
      <span class="o">.</span><span class="na">builder</span><span class="o">()</span>
      <span class="o">.</span><span class="na">withIntegerField</span><span class="o">(</span><span class="s">"appId"</span><span class="o">)</span>
      <span class="o">.</span><span class="na">withVarcharField</span><span class="o">(</span><span class="s">"description"</span><span class="o">)</span>
      <span class="o">.</span><span class="na">withTimestampField</span><span class="o">(</span><span class="s">"rowtime"</span><span class="o">)</span>
      <span class="o">.</span><span class="na">build</span><span class="o">();</span>

<span class="c1">// Create a concrete row with that type.</span>
<span class="n">Row</span> <span class="n">row</span> <span class="o">=</span> 
    <span class="n">Row</span>
      <span class="o">.</span><span class="na">withRowType</span><span class="o">(</span><span class="n">appType</span><span class="o">)</span>
      <span class="o">.</span><span class="na">addValues</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="s">"Some cool app"</span><span class="o">,</span> <span class="k">new</span> <span class="n">Date</span><span class="o">())</span>
      <span class="o">.</span><span class="na">build</span><span class="o">();</span>

<span class="c1">// Create a source PCollection containing only that row</span>
<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">testApps</span> <span class="o">=</span> 
    <span class="n">PBegin</span>
      <span class="o">.</span><span class="na">in</span><span class="o">(</span><span class="n">p</span><span class="o">)</span>
      <span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">Create</span>
                <span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">row</span><span class="o">)</span>
                <span class="o">.</span><span class="na">withCoder</span><span class="o">(</span><span class="n">appType</span><span class="o">.</span><span class="na">getRowCoder</span><span class="o">()));</span>
</code></pre>
    </div>
  </li>
  <li>
    <p><strong>From a <code class="highlighter-rouge">PCollection&lt;T&gt;</code> of records of some other type</strong>  (i.e.  <code class="highlighter-rouge">T</code> is not already a <code class="highlighter-rouge">Row</code>), by applying a <code class="highlighter-rouge">ParDo</code> that converts input records to <code class="highlighter-rouge">Row</code> format.</p>

    <p><strong>Note:</strong> you have to manually set the coder of the result by calling <code class="highlighter-rouge">setCoder(appType.getRowCoder())</code>:</p>
    <div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="c1">// An example POJO class.</span>
<span class="kd">class</span> <span class="nc">AppPojo</span> <span class="o">{</span>
  <span class="n">Integer</span> <span class="n">appId</span><span class="o">;</span>
  <span class="n">String</span> <span class="n">description</span><span class="o">;</span>
  <span class="n">Date</span> <span class="n">timestamp</span><span class="o">;</span>
<span class="o">}</span>

<span class="c1">// Acquire a collection of POJOs somehow.</span>
<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">AppPojo</span><span class="o">&gt;</span> <span class="n">pojos</span> <span class="o">=</span> <span class="o">...</span>

<span class="c1">// Convert them to Rows with the same schema as defined above via a DoFn.</span>
<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">apps</span> <span class="o">=</span> <span class="n">pojos</span>
  <span class="o">.</span><span class="na">apply</span><span class="o">(</span>
      <span class="n">ParDo</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="k">new</span> <span class="n">DoFn</span><span class="o">&lt;</span><span class="n">AppPojo</span><span class="o">,</span> <span class="n">Row</span><span class="o">&gt;()</span> <span class="o">{</span>
        <span class="nd">@ProcessElement</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">processElement</span><span class="o">(</span><span class="n">ProcessContext</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
          <span class="c1">// Get the current POJO instance</span>
          <span class="n">AppPojo</span> <span class="n">pojo</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="na">element</span><span class="o">();</span>

          <span class="c1">// Create a Row with the appType schema </span>
          <span class="c1">// and values from the current POJO</span>
          <span class="n">Row</span> <span class="n">appRow</span> <span class="o">=</span> 
                <span class="n">Row</span>
                  <span class="o">.</span><span class="na">withRowType</span><span class="o">(</span><span class="n">appType</span><span class="o">)</span>
                  <span class="o">.</span><span class="na">addValues</span><span class="o">(</span>
                    <span class="n">pojo</span><span class="o">.</span><span class="na">appId</span><span class="o">,</span> 
                    <span class="n">pojo</span><span class="o">.</span><span class="na">description</span><span class="o">,</span> 
                    <span class="n">pojo</span><span class="o">.</span><span class="na">timestamp</span><span class="o">)</span>
                  <span class="o">.</span><span class="na">build</span><span class="o">();</span>

          <span class="c1">// Output the Row representing the current POJO</span>
          <span class="n">c</span><span class="o">.</span><span class="na">output</span><span class="o">(</span><span class="n">appRow</span><span class="o">);</span>
        <span class="o">}</span>
      <span class="o">}))</span>
  <span class="o">.</span><span class="na">setCoder</span><span class="o">(</span><span class="n">appType</span><span class="o">.</span><span class="na">getRowCoder</span><span class="o">());</span>
</code></pre>
    </div>
  </li>
  <li>
    <p><strong>As an output of another <code class="highlighter-rouge">BeamSql</code> query</strong>. Details in the next section.</p>
  </li>
</ul>

<p>Once you have a <code class="highlighter-rouge">PCollection&lt;Row&gt;</code> in hand, you may use the <code class="highlighter-rouge">BeamSql</code> APIs to apply SQL queries to it.</p>

<h3 id="beamsql">BeamSql</h3>

<p><code class="highlighter-rouge">BeamSql.query(queryString)</code> method is the only API to create a <code class="highlighter-rouge">PTransform</code> from a string representation of the SQL query. You can apply this <code class="highlighter-rouge">PTransform</code> to either a single <code class="highlighter-rouge">PCollection</code> or a <code class="highlighter-rouge">PCollectionTuple</code> which holds multiple <code class="highlighter-rouge">PCollections</code>:</p>

<ul>
  <li>when applying to a single <code class="highlighter-rouge">PCollection</code> it can be referenced via the table name <code class="highlighter-rouge">PCOLLECTION</code> in the query:
    <div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="n">PCollection</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">filteredNames</span> <span class="o">=</span> <span class="n">testApps</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span>
    <span class="n">BeamSql</span><span class="o">.</span><span class="na">query</span><span class="o">(</span>
      <span class="s">"SELECT appId, description, rowtime "</span>
        <span class="o">+</span> <span class="s">"FROM PCOLLECTION "</span>
        <span class="o">+</span> <span class="s">"WHERE id=1"</span><span class="o">));</span>
</code></pre>
    </div>
  </li>
  <li>
    <p>when applying to a <code class="highlighter-rouge">PCollectionTuple</code>, the tuple tag for each <code class="highlighter-rouge">PCollection</code> in the tuple defines the table name that may be used to query it. Note that table names are bound to the specific <code class="highlighter-rouge">PCollectionTuple</code>, and thus are only valid in the context of queries applied to it.</p>

    <p>For example, you can join two <code class="highlighter-rouge">PCollections</code>:</p>
    <div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="c1">// Create the schema for reviews</span>
<span class="n">RowType</span> <span class="n">reviewType</span> <span class="o">=</span> 
    <span class="n">RowSqlType</span><span class="o">.</span>
      <span class="o">.</span><span class="na">withIntegerField</span><span class="o">(</span><span class="s">"appId"</span><span class="o">)</span>
      <span class="o">.</span><span class="na">withIntegerField</span><span class="o">(</span><span class="s">"reviewerId"</span><span class="o">)</span>
      <span class="o">.</span><span class="na">withFloatField</span><span class="o">(</span><span class="s">"rating"</span><span class="o">)</span>
      <span class="o">.</span><span class="na">withTimestampField</span><span class="o">(</span><span class="s">"rowtime"</span><span class="o">)</span>
      <span class="o">.</span><span class="na">build</span><span class="o">();</span>
    
<span class="c1">// Obtain the reviews records with this schema</span>
<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">reviewsRows</span> <span class="o">=</span> <span class="o">...</span>

<span class="c1">// Create a PCollectionTuple containing both PCollections.</span>
<span class="c1">// TupleTags IDs will be used as table names in the SQL query</span>
<span class="n">PCollectionTuple</span> <span class="n">namesAndFoods</span> <span class="o">=</span> <span class="n">PCollectionTuple</span><span class="o">.</span><span class="na">of</span><span class="o">(</span>
    <span class="k">new</span> <span class="n">TupleTag</span><span class="o">&lt;&gt;(</span><span class="s">"Apps"</span><span class="o">),</span> <span class="n">appsRows</span><span class="o">),</span> <span class="c1">// appsRows from the previous example</span>
    <span class="k">new</span> <span class="n">TupleTag</span><span class="o">&lt;&gt;(</span><span class="s">"Reviews"</span><span class="o">),</span> <span class="n">reviewsRows</span><span class="o">));</span>

<span class="c1">// Compute the total number of reviews </span>
<span class="c1">// and average rating per app </span>
<span class="c1">// by joining two PCollections</span>
<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">Row</span><span class="o">&gt;</span> <span class="n">output</span> <span class="o">=</span> <span class="n">namesAndFoods</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span>
    <span class="n">BeamSql</span><span class="o">.</span><span class="na">query</span><span class="o">(</span>
        <span class="s">"SELECT Names.appId, COUNT(Reviews.rating), AVG(Reviews.rating)"</span>
            <span class="o">+</span> <span class="s">"FROM Apps INNER JOIN Reviews ON Apps.appId == Reviews.appId"</span><span class="o">));</span>
</code></pre>
    </div>
  </li>
</ul>

<p><a href="https://github.com/apache/beam/blob/master/sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/example/BeamSqlExample.java">BeamSqlExample</a> in the code repository shows basic usage of both APIs.</p>

<h2 id="functionality">3. Functionality in Beam SQL</h2>
<p>Just as the unified model for both bounded and unbounded data in Beam, SQL DSL provides the same functionalities for bounded and unbounded <code class="highlighter-rouge">PCollection</code> as well. Here’s the supported SQL grammar supported in <a href="http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form">BNF</a>-like form. An <code class="highlighter-rouge">UnsupportedOperationException</code> is thrown for unsupported features.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>query:
	{
          select
      |   query UNION [ ALL ] query
      |   query MINUS [ ALL ] query
      |   query INTERSECT [ ALL ] query
	}
    [ ORDER BY orderItem [, orderItem ]* LIMIT count [OFFSET offset] ]

orderItem:
      expression [ ASC | DESC ]

select:
      SELECT
          { * | projectItem [, projectItem ]* }
      FROM tableExpression
      [ WHERE booleanExpression ]
      [ GROUP BY { groupItem [, groupItem ]* } ]
      [ HAVING booleanExpression ]

projectItem:
      expression [ [ AS ] columnAlias ]
  |   tableAlias . *

tableExpression:
      tableReference [, tableReference ]*
  |   tableExpression [ ( LEFT | RIGHT ) [ OUTER ] ] JOIN tableExpression [ joinCondition ]

booleanExpression:
    expression [ IS NULL | IS NOT NULL ]
  | expression [ &gt; | &gt;= | = | &lt; | &lt;= | &lt;&gt; ] expression
  | booleanExpression [ AND | OR ] booleanExpression
  | NOT booleanExpression
  | '(' booleanExpression ')'

joinCondition:
      ON booleanExpression

tableReference:
      tableName [ [ AS ] alias ]

values:
      VALUES expression [, expression ]*

groupItem:
      expression
  |   '(' expression [, expression ]* ')'
  |   HOP '(' expression [, expression ]* ')'
  |   TUMBLE '(' expression [, expression ]* ')'
  |   SESSION '(' expression [, expression ]* ')'

</code></pre>
</div>

<h3 id="features">3.1. Supported Features</h3>

<h4 id="features-aggregations">3.1.1 Aggregations</h4>

<p>Major standard aggregation functions are supported:</p>
<ul>
  <li><code class="highlighter-rouge">COUNT</code></li>
  <li><code class="highlighter-rouge">MAX</code></li>
  <li><code class="highlighter-rouge">MIN</code></li>
  <li><code class="highlighter-rouge">SUM</code></li>
  <li><code class="highlighter-rouge">AVG</code></li>
  <li><code class="highlighter-rouge">VAR_POP</code></li>
  <li><code class="highlighter-rouge">VAR_SAMP</code></li>
  <li><code class="highlighter-rouge">COVAR_POP</code></li>
  <li><code class="highlighter-rouge">COVAR_SAMP</code></li>
</ul>

<p><strong>Note:</strong> <code class="highlighter-rouge">DISTINCT</code> aggregation is not supported yet.</p>

<h4 id="features-windowing">3.1.2 Windowing</h4>

<p>Beam SQL supports windowing functions specified in <code class="highlighter-rouge">GROUP BY</code> clause. <code class="highlighter-rouge">TIMESTAMP</code> field is required in this case. It is used as event timestamp for rows.</p>

<p>Supported windowing functions:</p>
<ul>
  <li><code class="highlighter-rouge">TUMBLE</code>, or fixed windows. Example of how define a fixed window with duration of 1 hour:
    <div class="highlighter-rouge"><pre class="highlight"><code>  SELECT f_int, COUNT(*) 
  FROM PCOLLECTION 
  GROUP BY 
    f_int,
    TUMBLE(f_timestamp, INTERVAL '1' HOUR)
</code></pre>
    </div>
  </li>
  <li><code class="highlighter-rouge">HOP</code>, or sliding windows. Example of how to define a sliding windows for every 30 minutes with 1 hour duration:
    <div class="highlighter-rouge"><pre class="highlight"><code>  SELECT f_int, COUNT(*)
  FROM PCOLLECTION 
  GROUP BY 
    f_int, 
    HOP(f_timestamp, INTERVAL '30' MINUTE, INTERVAL '1' HOUR)
</code></pre>
    </div>
  </li>
  <li><code class="highlighter-rouge">SESSION</code>, session windows. Example of how to define a session window with 5 minutes gap duration:
    <div class="highlighter-rouge"><pre class="highlight"><code>  SELECT f_int, COUNT(*) 
  FROM PCOLLECTION 
  GROUP BY 
    f_int, 
    SESSION(f_timestamp, INTERVAL '5' MINUTE)
</code></pre>
    </div>
  </li>
</ul>

<p><strong>Note:</strong> when no windowing function is specified in the query, then windowing strategy of the input <code class="highlighter-rouge">PCollections</code> is unchanged by the SQL query. If windowing function is specified in the query, then the windowing function of the <code class="highlighter-rouge">PCollection</code> is updated accordingly, but trigger stays unchanged.</p>

<h4 id="features-joins">3.1.3 Joins</h4>

<h4 id="3131-overview">3.1.3.1 Overview</h4>

<p>Supported <code class="highlighter-rouge">JOIN</code> types in Beam SQL:</p>
<ul>
  <li><code class="highlighter-rouge">INNER</code>, <code class="highlighter-rouge">LEFT OUTER</code>, <code class="highlighter-rouge">RIGHT OUTER</code>;</li>
  <li>Only equijoins (where join condition is an equality check) are supported.</li>
</ul>

<p>Unsupported <code class="highlighter-rouge">JOIN</code> types in Beam SQL:</p>
<ul>
  <li><code class="highlighter-rouge">CROSS JOIN</code> is not supported (full cartesian product with no <code class="highlighter-rouge">ON</code> clause);</li>
  <li><code class="highlighter-rouge">FULL OUTER JOIN</code> is not supported (combination of <code class="highlighter-rouge">LEFT OUTER</code> and <code class="highlighter-rouge">RIGHT OUTER</code> joins);</li>
</ul>

<p>The scenarios of join can be categorized into 3 cases:</p>

<ol>
  <li>Bounded input <code class="highlighter-rouge">JOIN</code> bounded input;</li>
  <li>Unbounded input <code class="highlighter-rouge">JOIN</code> unbounded input;</li>
  <li>Unbounded input <code class="highlighter-rouge">JOIN</code> bounded input;</li>
</ol>

<p>Each of these scenarios is described below:</p>

<h4 id="join-bounded-bounded">3.1.3.1 Bounded JOIN Bounded</h4>

<p>Standard join implementation is used. All elements from one input are matched with all elements from another input. Due to the fact that both inputs are bounded, no windowing or triggering is involved.</p>

<h4 id="join-unbounded-unbounded">3.1.3.2 Unbounded JOIN Unbounded</h4>

<p>Standard join implementation is used. All elements from one input are matched with all elements from another input.</p>

<p><strong>Windowing and Triggering</strong></p>

<p>Following properties must be satisfied when joining unbounded inputs:</p>
<ul>
  <li>inputs must have compatible windows, otherwise <code class="highlighter-rouge">IllegalArgumentException</code> will be thrown;</li>
  <li>triggers on each input should only fire once per window. Currently this means that the only supported trigger in this case is <code class="highlighter-rouge">DefaultTrigger</code> with zero allowed lateness. Using any other trigger will result in <code class="highlighter-rouge">UnsupportedOperationException</code> thrown;</li>
</ul>

<p>This means that inputs are joined per-window. That is, when the trigger fires (only once), then join is performed on all elements in the current window in both inputs. This allows to reason about what kind of output is going to be produced.</p>

<p><strong>Note:</strong> similarly to <code class="highlighter-rouge">GroupByKeys</code> <code class="highlighter-rouge">JOIN</code> will update triggers using <code class="highlighter-rouge">Trigger.continuationTrigger()</code>. Other aspects of the inputs’ windowing strategies remain unchanged.</p>

<h4 id="join-unbounded-bounded">3.1.3.3 Unbounded JOIN Bounded</h4>

<p>For this type of <code class="highlighter-rouge">JOIN</code> bounded input is treated as a side-input by the implementation.</p>

<p>This means that</p>

<ul>
  <li>window/trigger is inherented from upstreams, which should be consistent;</li>
</ul>

<h4 id="features-udfs-udafs">3.1.4 User Defined Function (UDF) and User Defined Aggregate Function (UDAF)</h4>

<p>If the required function is not available, developers can register their own UDF(for scalar function) and UDAF(for aggregation function).</p>

<h5 id="3141-create-and-specify-user-defined-function-udf"><strong>3.1.4.1 Create and specify User Defined Function (UDF)</strong></h5>

<p>A UDF can be 1) any Java method that takes zero or more scalar fields and return one scalar value, or 2) a <code class="highlighter-rouge">SerializableFunction</code>. Below is an example of UDF and how to use it in DSL:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="cm">/**
 * A example UDF for test.
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">CubicInteger</span> <span class="kd">implements</span> <span class="n">BeamSqlUdf</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="n">Integer</span> <span class="nf">eval</span><span class="o">(</span><span class="n">Integer</span> <span class="n">input</span><span class="o">){</span>
    <span class="k">return</span> <span class="n">input</span> <span class="o">*</span> <span class="n">input</span> <span class="o">*</span> <span class="n">input</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/**
 * Another example UDF with {@link SerializableFunction}.
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">CubicIntegerFn</span> <span class="kd">implements</span> <span class="n">SerializableFunction</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">apply</span><span class="o">(</span><span class="n">Integer</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">input</span> <span class="o">*</span> <span class="n">input</span> <span class="o">*</span> <span class="n">input</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Define a SQL query which calls the above UDFs</span>
<span class="n">String</span> <span class="n">sql</span> <span class="o">=</span> 
    <span class="s">"SELECT f_int, cubic1(f_int), cubic2(f_int)"</span>
      <span class="o">+</span> <span class="s">"FROM PCOLLECTION "</span>
      <span class="o">+</span> <span class="s">"WHERE f_int = 2"</span><span class="o">;</span>

<span class="c1">// Create and apply the PTransform representing the query.</span>
<span class="c1">// Register the UDFs used in the query by calling '.registerUdf()' with </span>
<span class="c1">// either a class which implements BeamSqlUdf or with </span>
<span class="c1">// an instance of the SerializableFunction;</span>
<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">BeamSqlRow</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span>
    <span class="n">input</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span>
        <span class="s">"udfExample"</span><span class="o">,</span>
        <span class="n">BeamSql</span>
            <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="n">sql</span><span class="o">)</span>
            <span class="o">.</span><span class="na">registerUdf</span><span class="o">(</span><span class="s">"cubic1"</span><span class="o">,</span> <span class="n">CubicInteger</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
            <span class="o">.</span><span class="na">registerUdf</span><span class="o">(</span><span class="s">"cubic2"</span><span class="o">,</span> <span class="k">new</span> <span class="n">CubicIntegerFn</span><span class="o">())</span>
</code></pre>
</div>

<h5 id="3142-create-and-specify-user-defined-aggregate-function-udaf"><strong>3.1.4.2 Create and specify User Defined Aggregate Function (UDAF)</strong></h5>

<p>Beam SQL can accept a <code class="highlighter-rouge">CombineFn</code> as UDAF. Registration is similar to the UDF example above:</p>

<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="cm">/**
 * UDAF(CombineFn) for test, which returns the sum of square.
 */</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">SquareSum</span> <span class="kd">extends</span> <span class="n">CombineFn</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">createAccumulator</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">addInput</span><span class="o">(</span><span class="n">Integer</span> <span class="n">accumulator</span><span class="o">,</span> <span class="n">Integer</span> <span class="n">input</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">accumulator</span> <span class="o">+</span> <span class="n">input</span> <span class="o">*</span> <span class="n">input</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">mergeAccumulators</span><span class="o">(</span><span class="n">Iterable</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">accumulators</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">ite</span> <span class="o">=</span> <span class="n">accumulators</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">ite</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
      <span class="n">v</span> <span class="o">+=</span> <span class="n">ite</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">v</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="n">Integer</span> <span class="nf">extractOutput</span><span class="o">(</span><span class="n">Integer</span> <span class="n">accumulator</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">accumulator</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// Define a SQL query which calls the above UDAF</span>
<span class="n">String</span> <span class="n">sql</span> <span class="o">=</span> 
    <span class="s">"SELECT f_int1, squaresum(f_int2) "</span>
      <span class="o">+</span> <span class="s">"FROM PCOLLECTION "</span>
      <span class="o">+</span> <span class="s">"GROUP BY f_int2"</span><span class="o">;</span>
      
<span class="c1">// Create and apply the PTransform representing the query.</span>
<span class="c1">// Register the UDAFs used in the query by calling '.registerUdaf()' by </span>
<span class="c1">// providing it an instance of the CombineFn</span>
<span class="n">PCollection</span><span class="o">&lt;</span><span class="n">BeamSqlRow</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span>
    <span class="n">input</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span>
        <span class="s">"udafExample"</span><span class="o">,</span>
        <span class="n">BeamSql</span>
            <span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="n">sql</span><span class="o">)</span>
            <span class="o">.</span><span class="na">registerUdaf</span><span class="o">(</span><span class="s">"squaresum"</span><span class="o">,</span> <span class="k">new</span> <span class="n">SquareSum</span><span class="o">()));</span>
</code></pre>
</div>

<h3 id="data-types">3.2. Data Types</h3>
<p>Each type in Beam SQL maps to a Java class to holds the value in <code class="highlighter-rouge">Row</code>. The following table lists the relation between SQL types and Java classes, which are supported in current repository:</p>

<table class="table">
  <thead>
    <tr>
      <th>SQL Type</th>
      <th>Java class</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Types.INTEGER</td>
      <td>java.lang.Integer</td>
    </tr>
    <tr>
      <td>Types.SMALLINT</td>
      <td>java.lang.Short</td>
    </tr>
    <tr>
      <td>Types.TINYINT</td>
      <td>java.lang.Byte</td>
    </tr>
    <tr>
      <td>Types.BIGINT</td>
      <td>java.lang.Long</td>
    </tr>
    <tr>
      <td>Types.FLOAT</td>
      <td>java.lang.Float</td>
    </tr>
    <tr>
      <td>Types.DOUBLE</td>
      <td>java.lang.Double</td>
    </tr>
    <tr>
      <td>Types.DECIMAL</td>
      <td>java.math.BigDecimal</td>
    </tr>
    <tr>
      <td>Types.VARCHAR</td>
      <td>java.lang.String</td>
    </tr>
    <tr>
      <td>Types.TIMESTAMP</td>
      <td>java.util.Date</td>
    </tr>
  </tbody>
</table>

<h3 id="built-in-functions">3.3. Built-in SQL functions</h3>

<p>Beam SQL has implemented lots of build-in functions defined in <a href="http://calcite.apache.org">Apache Calcite</a>. The available functions are listed as below:</p>

<p><strong>Comparison functions and operators</strong></p>

<table class="table">
  <thead>
    <tr>
      <th>Operator syntax</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>value1 = value2</td>
      <td>Equals</td>
    </tr>
    <tr>
      <td>value1 &lt;&gt; value2</td>
      <td>Not equal</td>
    </tr>
    <tr>
      <td>value1 &gt; value2</td>
      <td>Greater than</td>
    </tr>
    <tr>
      <td>value1 &gt;= value2</td>
      <td>Greater than or equal</td>
    </tr>
    <tr>
      <td>value1 &lt; value2</td>
      <td>Less than</td>
    </tr>
    <tr>
      <td>value1 &lt;= value2</td>
      <td>Less than or equal</td>
    </tr>
    <tr>
      <td>value IS NULL</td>
      <td>Whether value is null</td>
    </tr>
    <tr>
      <td>value IS NOT NULL</td>
      <td>Whether value is not null</td>
    </tr>
  </tbody>
</table>

<p><strong>Logical functions and operators</strong></p>

<table class="table">
  <thead>
    <tr>
      <th>Operator syntax</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>boolean1 OR boolean2</td>
      <td>Whether boolean1 is TRUE or boolean2 is TRUE</td>
    </tr>
    <tr>
      <td>boolean1 AND boolean2</td>
      <td>Whether boolean1 and boolean2 are both TRUE</td>
    </tr>
    <tr>
      <td>NOT boolean</td>
      <td>Whether boolean is not TRUE; returns UNKNOWN if boolean is UNKNOWN</td>
    </tr>
  </tbody>
</table>

<p><strong>Arithmetic functions and operators</strong></p>

<table class="table">
  <thead>
    <tr>
      <th>Operator syntax</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>numeric1 + numeric2</td>
      <td>Returns numeric1 plus numeric2</td>
    </tr>
    <tr>
      <td>numeric1 - numeric2</td>
      <td>Returns numeric1 minus numeric2</td>
    </tr>
    <tr>
      <td>numeric1 * numeric2</td>
      <td>Returns numeric1 multiplied by numeric2</td>
    </tr>
    <tr>
      <td>numeric1 / numeric2</td>
      <td>Returns numeric1 divided by numeric2</td>
    </tr>
    <tr>
      <td>MOD(numeric, numeric)</td>
      <td>Returns the remainder (modulus) of numeric1 divided by numeric2. The result is negative only if numeric1 is negative</td>
    </tr>
  </tbody>
</table>

<p><strong>Math functions</strong></p>

<table class="table">
  <thead>
    <tr>
      <th>Operator syntax</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>ABS(numeric)</td>
      <td>Returns the absolute value of numeric</td>
    </tr>
    <tr>
      <td>SQRT(numeric)</td>
      <td>Returns the square root of numeric</td>
    </tr>
    <tr>
      <td>LN(numeric)</td>
      <td>Returns the natural logarithm (base e) of numeric</td>
    </tr>
    <tr>
      <td>LOG10(numeric)</td>
      <td>Returns the base 10 logarithm of numeric</td>
    </tr>
    <tr>
      <td>EXP(numeric)</td>
      <td>Returns e raised to the power of numeric</td>
    </tr>
    <tr>
      <td>ACOS(numeric)</td>
      <td>Returns the arc cosine of numeric</td>
    </tr>
    <tr>
      <td>ASIN(numeric)</td>
      <td>Returns the arc sine of numeric</td>
    </tr>
    <tr>
      <td>ATAN(numeric)</td>
      <td>Returns the arc tangent of numeric</td>
    </tr>
    <tr>
      <td>COT(numeric)</td>
      <td>Returns the cotangent of numeric</td>
    </tr>
    <tr>
      <td>DEGREES(numeric)</td>
      <td>Converts numeric from radians to degrees</td>
    </tr>
    <tr>
      <td>RADIANS(numeric)</td>
      <td>Converts numeric from degrees to radians</td>
    </tr>
    <tr>
      <td>SIGN(numeric)</td>
      <td>Returns the signum of numeric</td>
    </tr>
    <tr>
      <td>SIN(numeric)</td>
      <td>Returns the sine of numeric</td>
    </tr>
    <tr>
      <td>TAN(numeric)</td>
      <td>Returns the tangent of numeric</td>
    </tr>
    <tr>
      <td>ROUND(numeric1, numeric2)</td>
      <td>Rounds numeric1 to numeric2 places right to the decimal point</td>
    </tr>
  </tbody>
</table>

<p><strong>Date functions</strong></p>

<table class="table">
  <thead>
    <tr>
      <th>Operator syntax</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>LOCALTIME</td>
      <td>Returns the current date and time in the session time zone in a value of datatype TIME</td>
    </tr>
    <tr>
      <td>LOCALTIME(precision)</td>
      <td>Returns the current date and time in the session time zone in a value of datatype TIME, with precision digits of precision</td>
    </tr>
    <tr>
      <td>LOCALTIMESTAMP</td>
      <td>Returns the current date and time in the session time zone in a value of datatype TIMESTAMP</td>
    </tr>
    <tr>
      <td>LOCALTIMESTAMP(precision)</td>
      <td>Returns the current date and time in the session time zone in a value of datatype TIMESTAMP, with precision digits of precision</td>
    </tr>
    <tr>
      <td>CURRENT_TIME</td>
      <td>Returns the current time in the session time zone, in a value of datatype TIMESTAMP WITH TIME ZONE</td>
    </tr>
    <tr>
      <td>CURRENT_DATE</td>
      <td>Returns the current date in the session time zone, in a value of datatype DATE</td>
    </tr>
    <tr>
      <td>CURRENT_TIMESTAMP</td>
      <td>Returns the current date and time in the session time zone, in a value of datatype TIMESTAMP WITH TIME ZONE</td>
    </tr>
    <tr>
      <td>EXTRACT(timeUnit FROM datetime)</td>
      <td>Extracts and returns the value of a specified datetime field from a datetime value expression</td>
    </tr>
    <tr>
      <td>FLOOR(datetime TO timeUnit)</td>
      <td>Rounds datetime down to timeUnit</td>
    </tr>
    <tr>
      <td>CEIL(datetime TO timeUnit)</td>
      <td>Rounds datetime up to timeUnit</td>
    </tr>
    <tr>
      <td>YEAR(date)</td>
      <td>Equivalent to EXTRACT(YEAR FROM date). Returns an integer.</td>
    </tr>
    <tr>
      <td>QUARTER(date)</td>
      <td>Equivalent to EXTRACT(QUARTER FROM date). Returns an integer between 1 and 4.</td>
    </tr>
    <tr>
      <td>MONTH(date)</td>
      <td>Equivalent to EXTRACT(MONTH FROM date). Returns an integer between 1 and 12.</td>
    </tr>
    <tr>
      <td>WEEK(date)</td>
      <td>Equivalent to EXTRACT(WEEK FROM date). Returns an integer between 1 and 53.</td>
    </tr>
    <tr>
      <td>DAYOFYEAR(date)</td>
      <td>Equivalent to EXTRACT(DOY FROM date). Returns an integer between 1 and 366.</td>
    </tr>
    <tr>
      <td>DAYOFMONTH(date)</td>
      <td>Equivalent to EXTRACT(DAY FROM date). Returns an integer between 1 and 31.</td>
    </tr>
    <tr>
      <td>DAYOFWEEK(date)</td>
      <td>Equivalent to EXTRACT(DOW FROM date). Returns an integer between 1 and 7.</td>
    </tr>
    <tr>
      <td>HOUR(date)</td>
      <td>Equivalent to EXTRACT(HOUR FROM date). Returns an integer between 0 and 23.</td>
    </tr>
    <tr>
      <td>MINUTE(date)</td>
      <td>Equivalent to EXTRACT(MINUTE FROM date). Returns an integer between 0 and 59.</td>
    </tr>
    <tr>
      <td>SECOND(date)</td>
      <td>Equivalent to EXTRACT(SECOND FROM date). Returns an integer between 0 and 59.</td>
    </tr>
  </tbody>
</table>

<p><strong>String functions</strong></p>

<table class="table">
  <thead>
    <tr>
      <th>Operator syntax</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>string || string</td>
      <td>Concatenates two character strings</td>
    </tr>
    <tr>
      <td>CHAR_LENGTH(string)</td>
      <td>Returns the number of characters in a character string</td>
    </tr>
    <tr>
      <td>CHARACTER_LENGTH(string)</td>
      <td>As CHAR_LENGTH(string)</td>
    </tr>
    <tr>
      <td>UPPER(string)</td>
      <td>Returns a character string converted to upper case</td>
    </tr>
    <tr>
      <td>LOWER(string)</td>
      <td>Returns a character string converted to lower case</td>
    </tr>
    <tr>
      <td>POSITION(string1 IN string2)</td>
      <td>Returns the position of the first occurrence of string1 in string2</td>
    </tr>
    <tr>
      <td>POSITION(string1 IN string2 FROM integer)</td>
      <td>Returns the position of the first occurrence of string1 in string2 starting at a given point (not standard SQL)</td>
    </tr>
    <tr>
      <td>TRIM( { BOTH | LEADING | TRAILING } string1 FROM string2)</td>
      <td>Removes the longest string containing only the characters in string1 from the start/end/both ends of string1</td>
    </tr>
    <tr>
      <td>OVERLAY(string1 PLACING string2 FROM integer [ FOR integer2 ])</td>
      <td>Replaces a substring of string1 with string2</td>
    </tr>
    <tr>
      <td>SUBSTRING(string FROM integer)</td>
      <td>Returns a substring of a character string starting at a given point</td>
    </tr>
    <tr>
      <td>SUBSTRING(string FROM integer FOR integer)</td>
      <td>Returns a substring of a character string starting at a given point with a given length</td>
    </tr>
    <tr>
      <td>INITCAP(string)</td>
      <td>Returns string with the first letter of each word converter to upper case and the rest to lower case. Words are sequences of alphanumeric characters separated by non-alphanumeric characters.</td>
    </tr>
  </tbody>
</table>

<p><strong>Conditional functions</strong></p>

<table class="table">
  <thead>
    <tr>
      <th>Operator syntax</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>CASE value <br />WHEN value1 [, value11 ]* THEN result1 <br />[ WHEN valueN [, valueN1 ]* THEN resultN ]* <br />[ ELSE resultZ ] <br />END</td>
      <td>Simple case</td>
    </tr>
    <tr>
      <td>CASE <br />WHEN condition1 THEN result1 <br />[ WHEN conditionN THEN resultN ]* <br />[ ELSE resultZ ] <br />END</td>
      <td>Searched case</td>
    </tr>
    <tr>
      <td>NULLIF(value, value)</td>
      <td>Returns NULL if the values are the same. For example, NULLIF(5, 5) returns NULL; NULLIF(5, 0) returns 5.</td>
    </tr>
    <tr>
      <td>COALESCE(value, value [, value ]*)</td>
      <td>Provides a value if the first value is null. For example, COALESCE(NULL, 5) returns 5.</td>
    </tr>
  </tbody>
</table>

<p><strong>Type conversion functions</strong></p>

<p><strong>Aggregate functions</strong></p>

<table class="table">
  <thead>
    <tr>
      <th>Operator syntax</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>COUNT(*)</td>
      <td>Returns the number of input rows</td>
    </tr>
    <tr>
      <td>AVG(numeric)</td>
      <td>Returns the average (arithmetic mean) of numeric across all input values</td>
    </tr>
    <tr>
      <td>SUM(numeric)</td>
      <td>Returns the sum of numeric across all input values</td>
    </tr>
    <tr>
      <td>MAX(value)</td>
      <td>Returns the maximum value of value across all input values</td>
    </tr>
    <tr>
      <td>MIN(value)</td>
      <td>Returns the minimum value of value across all input values</td>
    </tr>
  </tbody>
</table>

<h2 id="internals-of-sql">4. Internals of Beam SQL</h2>
<p>Figure 1 describes the back-end steps from a SQL statement to a Beam <code class="highlighter-rouge">PTransform</code>.</p>

<p><img src="/images/beam_sql_dsl_workflow.png" alt="Workflow of Beam SQL DSL" title="workflow of Beam SQL DSL" /></p>

<p><strong>Figure 1</strong> workflow of Beam SQL DSL</p>

<p>Given a <code class="highlighter-rouge">PCollection</code> and the query as input, first of all the input <code class="highlighter-rouge">PCollection</code> is registered as a table in the schema repository. Then it’s processed as:</p>

<ol>
  <li>SQL query is parsed according to grammar to generate a SQL Abstract Syntax Tree;</li>
  <li>Validate against table schema, and output a logical plan represented with relational algebras;</li>
  <li>Relational rules are applied to convert it to a physical plan, expressed with Beam components. An optimizer is optional to update the plan;</li>
  <li>Finally, the Beam physical plan is compiled as a composite <code class="highlighter-rouge">PTransform</code>;</li>
</ol>

<p>Here is an example to show a query that filters and projects from an input <code class="highlighter-rouge">PCollection</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>SELECT USER_ID, USER_NAME FROM PCOLLECTION WHERE USER_ID = 1
</code></pre>
</div>

<p>The logical plan is shown as:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>LogicalProject(USER_ID=[$0], USER_NAME=[$1])
  LogicalFilter(condition=[=($0, 1)])
    LogicalTableScan(table=[[PCOLLECTION]])
</code></pre>
</div>

<p>And compiled as a composite <code class="highlighter-rouge">PTransform</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>pCollection.apply(BeamSqlFilter...)
           .apply(BeamSqlProject...)
</code></pre>
</div>

      </div>
    </div>
    <footer class="footer">
  <div class="footer__contained">
    <div class="footer__cols">
      <div class="footer__cols__col">
        <div class="footer__cols__col__logo">
          <img src="/images/beam_logo_circle.svg" class="footer__logo" alt="Beam logo">
        </div>
        <div class="footer__cols__col__logo">
          <img src="/images/apache_logo_circle.svg" class="footer__logo" alt="Apache logo">
        </div>
      </div>
      <div class="footer__cols__col footer__cols__col--md">
        <div class="footer__cols__col__title">Start</div>
        <div class="footer__cols__col__link"><a href="/get-started/beam-overview/">Overview</a></div>
        <div class="footer__cols__col__link"><a href="/get-started/quickstart-java/">Quickstart (Java)</a></div>
        <div class="footer__cols__col__link"><a href="/get-started/quickstart-py/">Quickstart (Python)</a></div>
        <div class="footer__cols__col__link"><a href="/get-started/downloads/">Downloads</a></div>
      </div>
      <div class="footer__cols__col footer__cols__col--md">
        <div class="footer__cols__col__title">Docs</div>
        <div class="footer__cols__col__link"><a href="/documentation/programming-guide/">Concepts</a></div>
        <div class="footer__cols__col__link"><a href="/documentation/pipelines/design-your-pipeline/">Pipelines</a></div>
        <div class="footer__cols__col__link"><a href="/documentation/runners/capability-matrix/">Runners</a></div>
      </div>
      <div class="footer__cols__col footer__cols__col--md">
        <div class="footer__cols__col__title">Community</div>
        <div class="footer__cols__col__link"><a href="/contribute/">Contribute</a></div>
        <div class="footer__cols__col__link"><a href="/contribute/team/">Team</a></div>
        <div class="footer__cols__col__link"><a href="/contribute/presentation-materials/">Media</a></div>
      </div>
      <div class="footer__cols__col footer__cols__col--md">
        <div class="footer__cols__col__title">Resources</div>
        <div class="footer__cols__col__link"><a href="/blog/">Blog</a></div>
        <div class="footer__cols__col__link"><a href="/get-started/support/">Support</a></div>
        <div class="footer__cols__col__link"><a href="https://github.com/apache/beam">GitHub</a></div>
      </div>
    </div>
  </div>
  <div class="footer__bottom">
    &copy;
    <a href="http://www.apache.org">The Apache Software Foundation</a>
    | <a href="/privacy_policy">Privacy Policy</a>
    | <a href="/feed.xml">RSS Feed</a>
    <br><br>
    Apache Beam, Apache, Beam, the Beam logo, and the Apache feather logo are
    either registered trademarks or trademarks of The Apache Software
    Foundation. All other products or name brands are trademarks of their
    respective holders, including The Apache Software Foundation.
  </div>
</footer>

  </body>
</html>
